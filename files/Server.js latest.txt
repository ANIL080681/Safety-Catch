// server.js
// This version includes a simulated master data source and an endpoint to retrieve user info.

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { google } = require('googleapis');
const { Storage } = require('@google-cloud/storage');
const multer = require('multer');

const app = express();
const port = process.env.PORT || 8080;

// --- Middleware ---
app.use(cors());
app.use(express.json());

// --- Google API Authentication ---
const auth = new google.auth.GoogleAuth({
    scopes: [
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/devstorage.full_control',
    ],
});

// --- Initialize Google Clients ---
const sheets = google.sheets({ version: 'v4', auth });
const storage = new Storage();
const bucket = storage.bucket(process.env.GCS_BUCKET_NAME || 'alocrbucket');

// --- File Upload Handling (Multer) ---
const upload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 },
});

// --- (NEW) Master Data Simulation ---
// In a real application, this data would come from a database.
const masterUserData = {
    "user123": {
        "name": "Anil Agarwal",
        "department": "Technical",
        "location": "Main Plant - Area 1"
    },
    "AL123": {
        "name": "Jaime Leong",
        "department": "Fit PMO, EAP Cluster",
        "location": "VISION EXCHANGE, 2 Venture Drive, SINGAPORE"
    }
};

// --- API Endpoints ---

/**
 * @route GET /getUserInfo
 * @description Retrieves user details from the master data source.
 */
app.get('/getUserInfo', (req, res) => {
    const { userId } = req.query;
    if (masterUserData[userId]) {
        res.status(200).json(masterUserData[userId]);
    } else {
        res.status(404).json({ message: "User not found." });
    }
});


app.post('/submitCatch', upload.single('attachment'), async (req, res) => {
    try {
        // Now includes userId to automatically fill in details
        const { description, location, subType, catchCategory, approver, department, userId } = req.body;
        let fileUrl = null;
        
        // Get user info from master data if it exists
        const userInfo = masterUserData[userId] || {};
        const finalDepartment = department || userInfo.department || '';
        const finalLocation = location || userInfo.location || '';


        if (req.file) {
            const blob = bucket.file(`catch-attachments/${Date.now()}-${req.file.originalname}`);
            const blobStream = blob.createWriteStream({
                resumable: false,
                contentType: req.file.mimetype,
            });

            await new Promise((resolve, reject) => {
                blobStream.on('finish', async () => {
                    try {
                        const options = { version: 'v4', action: 'read', expires: Date.now() + 15 * 60 * 1000 };
                        const [url] = await blob.getSignedUrl(options);
                        fileUrl = url;
                        resolve();
                    } catch (error) {
                        reject(new Error('Failed to generate signed URL.'));
                    }
                });
                blobStream.on('error', (err) => reject(new Error(`Unable to upload file: ${err.message}`)));
                blobStream.end(req.file.buffer);
            });
        }

        const spreadsheetId = '1Rq4mk94H7KeU7NZMWJ1I418nF32WHtm1DGf5tpUGwr4';
        const incidentId = `CATCH-${Date.now()}`;
        const timestamp = new Date().toISOString();
        
        const newRow = [
            incidentId, timestamp, description || 'See attached document.', finalLocation,
            subType || '', catchCategory || '', finalDepartment,
            approver || '', fileUrl || 'N/A', 'Submitted', 'Pending'
        ];

        await sheets.spreadsheets.values.append({
            spreadsheetId,
            range: 'Sheet1!A:K',
            valueInputOption: 'USER_ENTERED',
            resource: { values: [newRow] },
        });

        res.status(200).json({ 
            success: true, 
            incidentId, 
            message: `CATCH ${incidentId} submitted successfully.`
        });

    } catch (error) {
        console.error('Error in /submitCatch endpoint:', error);
        res.status(500).json({ success: false, message: error.message || 'An internal server error occurred.' });
    }
});

app.post('/approveCatch', async (req, res) => {
    const { incidentId } = req.body;
    const spreadsheetId = '1Rq4mk94H7KeU7NZMWJ1I418nF32WHtm1DGf5tpUGwr4';

    try {
        const response = await sheets.spreadsheets.values.get({ spreadsheetId, range: 'Sheet1!A:K' });
        const rows = response.data.values;
        if (!rows || rows.length === 0) {
            return res.status(404).json({ success: false, message: 'Sheet is empty.' });
        }
        
        const rowIndex = rows.findIndex(row => row[0] === incidentId);
        if (rowIndex === -1) {
            return res.status(404).json({ success: false, message: `CATCH ID ${incidentId} not found.` });
        }
        
        const targetCell = `Sheet1!K${rowIndex + 1}`; 
        await sheets.spreadsheets.values.update({
            spreadsheetId,
            range: targetCell,
            valueInputOption: 'USER_ENTERED',
            resource: { values: [['Approved']] },
        });
        
        res.status(200).json({ success: true, message: `CATCH ${incidentId} has been approved.` });
    } catch (error) {
        console.error('Error approving CATCH:', error);
        res.status(500).json({ success: false, message: 'Failed to approve CATCH.' });
    }
});

app.get('/getCatchStatus', async (req, res) => {
    const { incidentId } = req.query;
    const spreadsheetId = '1Rq4mk94H7KeU7NZMWJ1I418nF32WHtm1DGf5tpUGwr4';

    try {
        const response = await sheets.spreadsheets.values.get({ spreadsheetId, range: 'Sheet1!A:K' });
        const rows = response.data.values;
        if (rows && rows.length) {
            const incidentRow = rows.find(row => row[0] === incidentId);
            if (incidentRow) {
                const [id, time, desc, loc, sub, cat, dept, appr, url, stat, apprStat] = incidentRow;
                res.status(200).json({
                    success: true,
                    status: stat || 'No Status',
                    approvalStatus: apprStat || 'No Status',
                    approver: appr || 'Not specified',
                    catchCategory: cat || 'Not specified',
                    department: dept || 'Not specified',
                    details: `CATCH reported on ${new Date(time).toLocaleString()}. Category: ${cat}. Location: ${loc}.`
                });
            } else {
                res.status(404).json({ success: false, status: 'Not Found' });
            }
        } else {
            res.status(404).json({ success: false, status: 'Sheet is empty or unreadable.' });
        }
    } catch (error) {
        console.error('Error reading from sheet:', error);
        res.status(500).json({ success: false, message: 'Failed to read from sheet.' });
    }
});


app.listen(port, () => {
    console.log(`Backend server listening at http://localhost:${port}`);
});
