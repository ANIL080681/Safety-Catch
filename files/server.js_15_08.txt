// server.js
// This server handles form submissions, approvals, status checks, user info lookups,
// and now includes secure endpoints for Gemini and BigQuery.

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { google } = require('googleapis');
const { Storage } = require('@google-cloud/storage');
const multer = require('multer');
const { BigQuery } = require('@google-cloud/bigquery'); // Added for BigQuery
const fetch = require('node-fetch'); // Added for Gemini proxy

const app = express();
const port = process.env.PORT || 8080;

// --- Middleware ---
app.use(cors());
app.use(express.json());

// --- Google API Authentication ---
// This automatically finds your credentials when running on Google Cloud,
// or uses the file specified by GOOGLE_APPLICATION_CREDENTIALS env var.
const auth = new google.auth.GoogleAuth({
    scopes: [
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/devstorage.full_control',
        'https://www.googleapis.com/auth/cloud-platform', // Added scope for BigQuery/AI Platform
        'https://www.googleapis.com/auth/drive.readonly', // ADD THIS LINE
    ],
});

// --- Initialize Google Clients ---
const sheets = google.sheets({ version: 'v4', auth });
const storage = new Storage();
const bigquery = new BigQuery(); // Initialize BigQuery Client
const bucket = storage.bucket(process.env.GCS_BUCKET_NAME || 'alocrbucket');

// --- File Upload Handling (Multer) ---
const upload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10 MB file size limit
});

// --- Master Data Simulation ---
const masterUserData = {
    "user123": {
        "name": "Anil Agarwal",
        "department": "Technical",
        "location": "Main Plant - Area 1"
    },
    "AL123": {
        "name": "Jaime Leong",
        "department": "Fit PMO, EAP Cluster",
        "location": "VISION EXCHANGE, 2 Venture Drive, SINGAPORE"
    }
};

// --- Existing API Endpoints ---

app.get('/getUserInfo', (req, res) => {
    const { userId } = req.query;
    if (masterUserData[userId]) {
        res.status(200).json(masterUserData[userId]);
    } else {
        res.status(404).json({ message: "User not found." });
    }
});

app.post('/submitCatch', upload.single('attachment'), async (req, res) => {
    try {
        const { description, location, subType, catchCategory, approver, department, userId } = req.body;
        let fileUrl = null;
        
        const userInfo = masterUserData[userId] || {};
        const finalDepartment = department || userInfo.department || '';
        const finalLocation = location || userInfo.location || '';

        if (req.file) {
            const blob = bucket.file(`catch-attachments/${Date.now()}-${req.file.originalname}`);
            const blobStream = blob.createWriteStream({ resumable: false, contentType: req.file.mimetype });

            await new Promise((resolve, reject) => {
                blobStream.on('finish', () => {
                    fileUrl = `https://storage.googleapis.com/${bucket.name}/${blob.name}`;
                    resolve();
                }).on('error', (err) => {
                    reject(new Error(`Unable to upload file: ${err.message}`));
                });
                blobStream.end(req.file.buffer);
            });
        }

        const spreadsheetId = process.env.SPREADSHEET_ID || '1Rq4mk94H7KeU7NZMWJ1I418nF32WHtm1DGf5tpUGwr4';
        const incidentId = `CATCH-${Date.now()}`;
        const timestamp = new Date().toISOString();
        
        const newRow = [
            incidentId, timestamp, description || 'See attached document.', finalLocation,
            subType || '', catchCategory || '', finalDepartment,
            approver || '', fileUrl || 'N/A', 'Submitted', 'Pending'
        ];

        await sheets.spreadsheets.values.append({
            spreadsheetId,
            range: 'Sheet1!A:K',
            valueInputOption: 'USER_ENTERED',
            resource: { values: [newRow] },
        });

        res.status(200).json({ 
            success: true, 
            incidentId, 
            message: `CATCH ${incidentId} submitted successfully.`
        });

    } catch (error) {
        console.error('Error in /submitCatch endpoint:', error);
        res.status(500).json({ success: false, message: error.message || 'An internal server error occurred.' });
    }
});

app.post('/approveCatch', async (req, res) => {
    const { incidentId } = req.body;
    const spreadsheetId = process.env.SPREADSHEET_ID || '1Rq4mk94H7KeU7NZMWJ1I418nF32WHtm1DGf5tpUGwr4';

    try {
        const response = await sheets.spreadsheets.values.get({ spreadsheetId, range: 'Sheet1!A:K' });
        const rows = response.data.values;
        if (!rows || rows.length === 0) {
            return res.status(404).json({ success: false, message: 'Sheet is empty.' });
        }
        
        const rowIndex = rows.findIndex(row => row && row[0] === incidentId);
        if (rowIndex === -1) {
            return res.status(404).json({ success: false, message: `CATCH ID ${incidentId} not found.` });
        }
        
        const targetCell = `Sheet1!K${rowIndex + 1}`; 
        await sheets.spreadsheets.values.update({
            spreadsheetId,
            range: targetCell,
            valueInputOption: 'USER_ENTERED',
            resource: { values: [['Approved']] },
        });
        
        res.status(200).json({ success: true, message: `CATCH ${incidentId} has been approved.` });
    } catch (error) {
        console.error('Error approving CATCH:', error);
        res.status(500).json({ success: false, message: 'Failed to approve CATCH.' });
    }
});

app.get('/getCatchStatus', async (req, res) => {
    const { incidentId } = req.query;
    const spreadsheetId = process.env.SPREADSHEET_ID || '1Rq4mk94H7KeU7NZMWJ1I418nF32WHtm1DGf5tpUGwr4';

    try {
        const response = await sheets.spreadsheets.values.get({ spreadsheetId, range: 'Sheet1!A:K' });
        const rows = response.data.values;
        if (rows && rows.length) {
            const incidentRow = rows.find(row => row && row[0] === incidentId);
            if (incidentRow) {
                const [id, time, desc, loc, sub, cat, dept, appr, url, stat, apprStat] = incidentRow;
                res.status(200).json({
                    success: true,
                    status: stat || 'No Status',
                    approvalStatus: apprStat || 'No Status',
                    details: `CATCH ${id} reported on ${new Date(time).toLocaleString()} in category '${cat}' is currently: ${apprStat || 'Pending'}.`
                });
            } else {
                res.status(404).json({ success: false, message: 'Incident not found.' });
            }
        } else {
            res.status(404).json({ success: false, message: 'Sheet is empty or unreadable.' });
        }
    } catch (error) {
        console.error('Error reading from sheet:', error);
        res.status(500).json({ success: false, message: 'Failed to read from sheet.' });
    }
});


// --- NEW: Secure Gemini API Proxy Endpoint ---
/**
 * @route POST /callGemini
 * @description Securely calls the Gemini API on behalf of the frontend.
 */
app.post('/callGemini', async (req, res) => {
    const { contents, tools } = req.body;
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

    if (!GEMINI_API_KEY) {
        return res.status(500).json({ message: "Gemini API key is not configured on the server." });
    }
    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;

    try {
        const geminiResponse = await fetch(GEMINI_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents, tools }),
        });
        const data = await geminiResponse.json();
        res.status(geminiResponse.status).json(data);
    } catch (error) {
        console.error('Error proxying to Gemini API:', error);
        res.status(500).json({ message: 'Error calling Gemini API' });
    }
});


// --- NEW: BigQuery Query Endpoint ---
/**
 * @route POST /queryBigQuery
 * @description Executes a SQL query against BigQuery on behalf of the frontend.
 */
app.post('/queryBigQuery', async (req, res) => {
    const { query } = req.body;

    if (!query) {
        return res.status(400).json({ error: 'A SQL query is required.' });
    }

    try {
        const options = {
            query: query,
            // Make sure this location matches your BigQuery dataset's location.
            location: 'US', 
        };

        const [rows] = await bigquery.query(options);
        res.status(200).json(rows);

    } catch (error) {
        console.error('BIGQUERY ERROR:', error);
        res.status(500).json({ error: error.message });
    }
});


// --- Start Server ---
const host = '0.0.0.0';
app.listen(port, host, () => {
    console.log(`Backend server listening at http://${host}:${port}`);
});